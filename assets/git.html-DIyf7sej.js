import{_ as e,o as a,c as t,a as s}from"./app-DkcO9f_T.js";const i={},n=s(`<h1 id="git" tabindex="-1"><a class="header-anchor" href="#git"><span>Git</span></a></h1><p>[TOC]</p><h2 id="工作区、暂存区、版本库" tabindex="-1"><a class="header-anchor" href="#工作区、暂存区、版本库"><span>工作区、暂存区、版本库</span></a></h2><p>工作区：工作区就是在我们电脑中能看到的目录，即文件和文件夹的实际位置，我们直接在这里进行代码编辑，添加或者删除文件</p><p>暂存区：暂存区在git中被称为staged或index，位于.git目录下的index文件中，当我们对工作区的文件进行修改后，需要使用<code>git add</code>命令将修改过的文件添加到暂存区，这样修改后的文件状态才会被记录下来，准备提交到版本库中。</p><p>版本库：存放所有已经提交到本地仓库的代码版本</p><p>如何创建git仓库</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git init</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何将工作区的文件添加到暂存区</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git add &lt;文件名&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何将暂存区的内容存储到版本库</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git commit</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-m 表示添加备注信息</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git commit -m &quot;添加readme.txt&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何比较暂存区与工作区文件的差异：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git diff &lt;文件名&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何将文件从暂存区中删除</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git restore --staged &lt;文件名&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何查看分支的所有版本</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git log</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以使用一行来显示：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git log --pretty=oneline</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何将代码回滚到上一个版本：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git reset --hard HEAD^</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中HEAD^表示回滚一个版本，HEAD^^表示回滚两个版本，依次类推</p><p>需要注意的是，这里的回退并不会真的改变版本库，我们可以用下面的命令查看log</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git reflog</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们使用下面的命令回滚到任意节点：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git reset --hard 版本号</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>--soft 、 --mixed、 --hard的区别</p></blockquote><ul><li><strong>git reset --soft</strong>：‌此模式保留工作目录的内容，‌并将因重置HEAD所带来的新的文件差异放进暂存区。‌这意味着，‌使用--soft参数时，‌你的工作目录中的修改不会被删除，‌而是被保留下来，‌同时，‌由于重置HEAD引起的任何新的文件差异将被添加到暂存区，‌准备提交。‌</li><li><strong>git reset --mixed（‌默认）‌</strong>：‌这是git reset命令的默认模式，‌它保留工作目录的内容，‌但重置暂存区（‌Index）‌与HEAD指定的状态保持一致。‌换句话说，‌所有已经git add到暂存区的更改会被取消，‌但工作目录中的更改（‌未提交的更改）‌则保持不变。‌</li><li><strong>git reset --hard</strong>：‌此模式会重置缓存区和工作目录里的内容，‌使它们与HEAD的新位置相同。‌换句话说，‌当你使用--hard参数时，‌你的缓存区和工作目录里的内容会被完全重置为和HEAD的新位置相同的内容。‌这表示，‌所有未提交的修改都会被丢弃。‌</li></ul><p>如何恢复文件</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git restore readme.md</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如何创建分支</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">git checkout -b &lt;分支名&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>什么是cherry-pick</p><p>merge和rebase</p>`,37),l=[n];function d(c,p){return a(),t("div",null,l)}const g=e(i,[["render",d],["__file","git.html.vue"]]),o=JSON.parse('{"path":"/article/tools/git/git.html","title":"Git","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"工作区、暂存区、版本库","slug":"工作区、暂存区、版本库","link":"#工作区、暂存区、版本库","children":[]}],"git":{"updatedTime":1721357602000,"contributors":[{"name":"codePiece","email":"1749967714@qq.com","commits":1}]},"filePathRelative":"article/tools/git/git.md","excerpt":"\\n<p>[TOC]</p>\\n<h2>工作区、暂存区、版本库</h2>\\n<p>工作区：工作区就是在我们电脑中能看到的目录，即文件和文件夹的实际位置，我们直接在这里进行代码编辑，添加或者删除文件</p>\\n<p>暂存区：暂存区在git中被称为staged或index，位于.git目录下的index文件中，当我们对工作区的文件进行修改后，需要使用<code>git add</code>命令将修改过的文件添加到暂存区，这样修改后的文件状态才会被记录下来，准备提交到版本库中。</p>\\n<p>版本库：存放所有已经提交到本地仓库的代码版本</p>\\n<p>如何创建git仓库</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code><span class=\\"line\\">git init</span>\\n<span class=\\"line\\"></span></code></pre></div>"}');export{g as comp,o as data};
